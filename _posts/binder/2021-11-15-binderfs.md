---
title: Binderfs
date: 2021-11-12 13:14:00 +09:00
categories: [binder, linux kernel]
tags: [binderfs, binder]
description: Analysis of binderfs
---

# 1. PreRequisite
## 1.1. mount

슈퍼 블록(super block)
파일 시스템을 기술하는 정보를 저장한다.파일 시스템마다 하나씩 존재한다. 슈퍼 블록의 자료 구조, 파일 시스템의 크기, 블록의 수, 이용가능한 빈 블록 목록, 빈 블록 목록에서 그 다음의 빈 블록을 가리키는 인덱스, 아이노드 목록의 크기, 빈 아이노드의 수, 빈 아이노드 목록, 빈 아이노드 목록에서 그 다음의 빈 아이노드를 가리키는 인덱스, 빈 블록과 빈 아이노드 목록들에 대한 록 필드들, 슈퍼 블록들 수정되었는지 나타내는 플래그, 파일 시스템의 이름, 디스크 이름 정보들이 저장된다.


#mount  -t  ext2  /dev/fd0  /tmp 등의 명령어를 입력하면 아래와 같은 순서로 함수가 호출된다.(이미 마운트 된 파일 시스템이 아니라면..즉 sb가 이미 등록되어있지 않다면..)
**mount() -> sys_mount() -> do_mount() -> do_new_mount() -> do_kernel_mount -> (filesystem_type->get_sb()) -> ext2_get_sb -> get_sb_bdev**
1. 커널은 마운트 연산에 대한 마운트 포인트(디렉토리), 장치 파일명 및 플래그를 통해 vfsmount 구조체를  만들어야 한다.
2. 해당 파일 시스템에 대한 슈퍼 블럭을 채우는것은 각 파일시스템에서 제공하는 함수를 통해 설정한다 (ext2의 경우 ext2_fill_super)
3. 파일시스템에서 받은 sb를(슬랩 할당자에서 받는다) vfsmount의 mnt_sb로 설정하고 나머지 마운트 포인트, 장치파일 이름, 플래그 등을 vfsmount 객체에 설정하고 리턴한다.

- do_new_mount  :  vfsmount 를 등록
- vfs_kern_mount : 장치 파일에 대해 vfsmount를 할당받고 파일 시스템 get_sb를 호출
- get_sb_bdev     :  파일시스템에 해당하는 디스크의 슈퍼 블록 데이터로 만든 sb 객체를 vfsmount에 설정
- sys_mount : 시스템 콜로 경로명, 장치 파일 경로, 파일 시스템 유형등을 받아서 처리를 요청한다.

**fill_super의 사용 함수**
```c
struct dentry *mount_nodev(struct file_system_type *fs_type,
	int flags, void *data,
	int (*fill_super)(struct super_block *, void *, int))
{
	int error;
	struct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL);

	if (IS_ERR(s))
		return ERR_CAST(s);

	error = fill_super(s, data, flags & SB_SILENT ? 1 : 0);
	if (error) {
		deactivate_locked_super(s);
		return ERR_PTR(error);
	}
	s->s_flags |= SB_ACTIVE;
	return dget(s->s_root);
}
```
  
  
# 2. binderfs introducing
## 2.1. Abstract
bindfs는 Android의 바인더 IPC 메커니즘을 위한 이전 버전과 호환되는 파일 시스템입니다. 각 ipc 네임스페이스는 새 bindfs 인스턴스를 마운트합니다. 동일한 ipc 이름 공간의 다른 위치에 바인더fs를 여러 번 마운트하면 새 수퍼 블록이 할당되지 않으므로 동일한 파일 시스템 인스턴스가 됩니다.
각각의 새로운 바인더fs 마운트는 자신이 마운트된 ipc 네임스페이스에서만 볼 수 있는 고유한 바인더 장치 세트를 갖습니다. 새 바인더fs 마운트의 모든 장치는 바인더%d 구성표를 따르고 번호는 항상 0에서 시작합니다.
    
## 2.2. Compatability
초기 ipc 네임스페이스에 대해 CONFIG_ANDROID_BINDER_DEVICES를 통해 Kconfig에서 요청된 장치는 이전과 같이 작동합니다. misc_register()를 통해 등록되고 devtmpfs 마운트에 나타납니다. 특히 표준 장치 바인더, hwbinder 및 vndbinder는 모두 /dev의 표준 위치에 나타납니다. 초기 ipc 네임스페이스에서 바인더fs 마운트를 마운트하거나 마운트 해제해도 이러한 장치에는 영향을 미치지 않습니다. 즉, 바인더프 마운트에 표시되지 않으며 바인더프 마운트가 사라지면 사라지지 않습니다.
    
## 2.3. 바인더 제어
각각의 새로운 바인더프 인스턴스는 바인더 제어 장치와 함께 제공됩니다. 처음에는 다른 장치가 표시되지 않습니다. 바인더 제어 장치를 사용하여 바인더 장치를 동적으로 할당할 수 있습니다. 모든 요청은 바인더 제어 장치가 있는 바인더프 마운트에서 작동합니다.
새로운 bindfs 인스턴스가 mount -t 바인더fs 바인더fs /dev/binderfs를 통해 /dev/binderfs에 마운트되었다고 가정합니다. 그러면 [2]와 같이 새로운 바인더 장치 생성을 요청할 수 있습니다. Binderfs 장치는 unlink()를 통해 간단히 제거할 수 있습니다.
    
## 2.4. 구현 세부사항
- 동적 주 번호 할당: 바인더fs가 새 파일 시스템으로 등록되면 새 주 번호를 동적으로 할당합니다. 할당된 주 번호는 새 바인더 장치가 할당될 때 struct binderfs_device에 반환됩니다.
- 글로벌 마이너 번호 추적: 마이너는 BINDERFS_MAX_MINOR로 제한되는 글로벌 idr 구조체에서 추적됩니다. 부 번호 추적기는 전역 뮤텍스로 보호됩니다. 이것은 바인더fs 마운트 사이의 유일한 경합 지점입니다.
- struct 바인더fs_info: 각 바인더fs 슈퍼 블록에는 바인더fs 인스턴스에 대한 특정 세부 정보를 추적하는 자체 구조체 바인더fs_info가 있습니다.
- IPC 네임스페이스
- 바인더 제어 장치의 덴트리
- 바인더fs 인스턴스가 마운트된 사용자 네임스페이스의 루트 uid 및 루트 gid
- 사용자 네임스페이스 루트에 의해 마운트 가능: 바인더fs는 초기 사용자 네임스페이스가 아닌 사용자 네임스페이스 루트에 의해 마운트될 수 있습니다. 장치는 사용자 네임스페이스 루트가 소유합니다.
- 기타 기반구조가 없는 바인더fs 바인더 장치: 바인더fs 마운트와 관련된 새 바인더 장치는 전체 misc_register() 기반구조를 사용하지 않습니다.

misc_register() 인프라는 호스트의 devtmpfs 마운트에서만 새 장치를 만들 수 있습니다. 그러나 바인더fs는 장치가 자체 마운트 지점 아래에만 나타나도록 하므로 슈퍼 블록의 루트 덴트리의 inode에서 새 문자 장치 노드를 할당합니다. 이것은 bindfs 특정 장치 노드가 sysfs에 나타나지 않는다는 부작용을 낳습니다. 이 동작은 devpts에 할당된 pts 장치와 유사하며 ipc 메커니즘 자체의 기능에는 영향을 미치지 않습니다.

### 2.4.1. mount 불리는 부분
binderfs mount는 안드로이드 initrc에서 처음 시작된다.
```sh
    # Mount binderfs
    mkdir /dev/binderfs
    mount binder binder /dev/binderfs stats=global
    chmod 0755 /dev/binderfs
```

# 3. Vulnerability

## 3.1. binder: prevent UAF read in print_binder_transaction_log_entry()
### 3.1.1. commit information
commit 51d8a7eca67784b155a07aeab4bfb9f63ebaaf9e>  
Author: Christian Brauner <christian.brauner@ubuntu.com>  
Date:   Tue Oct 8 15:01:59 2019 +0200  

binder: prevent UAF read in print_binder_transaction_log_entry()

```diff
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index c0a491277aca..5b9ac2122e89 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -57,6 +57,7 @@
 #include <linux/sched/signal.h>
 #include <linux/sched/mm.h>
 #include <linux/seq_file.h>
+#include <linux/string.h>
 #include <linux/uaccess.h>
 #include <linux/pid_namespace.h>
 #include <linux/security.h>
@@ -66,6 +67,7 @@
 #include <linux/task_work.h>
 
 #include <uapi/linux/android/binder.h>
+#include <uapi/linux/android/binderfs.h>
 
 #include <asm/cacheflush.h>
 
@@ -2876,7 +2878,7 @@ static void binder_transaction(struct binder_proc *proc,
        e->target_handle = tr->target.handle;
        e->data_size = tr->data_size;
        e->offsets_size = tr->offsets_size;
-       e->context_name = proc->context->name;
+       strscpy(e->context_name, proc->context->name, BINDERFS_MAX_NAME);
 
        if (reply) {
                binder_inner_proc_lock(proc);
diff --git a/drivers/android/binder_internal.h b/drivers/android/binder_internal.h
index bd47f7f72075..ae991097d14d 100644
--- a/drivers/android/binder_internal.h
+++ b/drivers/android/binder_internal.h
@@ -130,7 +130,7 @@ struct binder_transaction_log_entry {
        int return_error_line;
        uint32_t return_error;
        uint32_t return_error_param;
-       const char *context_name;
+       char context_name[BINDERFS_MAX_NAME + 1];
 };
 
 struct binder_transaction_log {

```
### 3.1.2. vulnerability description
바인더 트랜잭션이 바인더FS 인스턴스에서 오는 바인더 장치에서 시작되면 바인더 장치 이름에 대한 포인터가 바인더_transaction_log_entry의 context_name 멤버에 참조진다. 나중에 이 이름은 print_binder_transaction_log_entry()에서 이름을 인쇄하는 데 사용된다. print_binder_transaction_log_entry()가 context_name에 액세스할 때 binder afs_evict_inode()는 이미 관련 메모리를 해제하여 UAF를 유발할 수 있다. 포인터를 참조하는 대신 바인더 장치의 이름을 복사하여 이를 방지한다.
## 3.2. binder: prevent UAF for binderfs devices 
### 3.2.1. commit description
commit 2669b8b0c798fbe1a31d49e07aa33233d469ad9b  
Author: Christian Brauner <christian.brauner@ubuntu.com>  
Date:   Fri Feb 21 19:01:24 2020 +0100  

binder: prevent UAF for binderfs devices
```diff
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index a6b2082c24f8..3069a0bad50f 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -5221,7 +5221,7 @@ static int binder_open(struct inode *nodp, struct file *filp)
        proc->default_priority = task_nice(current);
        /* binderfs stashes devices in i_private */
        if (is_binderfs_device(nodp)) {
-               binder_dev = nodp->i_private;
+               binder_dev = binderfs_device_get(nodp->i_private);
                info = nodp->i_sb->s_fs_info;
                binder_binderfs_dir_entry_proc = info->proc_log_dir;
        } else {
@@ -5405,6 +5405,7 @@ static int binder_node_release(struct binder_node *node, int refs)
 static void binder_deferred_release(struct binder_proc *proc)
 {
        struct binder_context *context = proc->context;
+       struct binder_device *device;
        struct rb_node *n;
        int threads, nodes, incoming_refs, outgoing_refs, active_transactions;
 
@@ -5484,6 +5485,8 @@ static void binder_deferred_release(struct binder_proc *proc)
                     outgoing_refs, active_transactions);
 
        binder_proc_dec_tmpref(proc);
+       device = container_of(proc->context, struct binder_device, context);
+       binderfs_device_put(device);
 }
 
 static void binder_deferred_func(struct work_struct *work)
diff --git a/drivers/android/binder_internal.h b/drivers/android/binder_internal.h
index ae991097d14d..73941d3382f3 100644
--- a/drivers/android/binder_internal.h
+++ b/drivers/android/binder_internal.h
@@ -35,6 +35,19 @@ struct binder_device {
        struct inode *binderfs_inode;
 };
 
+static inline struct binder_device *binderfs_device_get(struct binder_device *dev)
+{
+       if (dev->binderfs_inode)
+               ihold(dev->binderfs_inode);
+       return dev;
+}
+
+static inline void binderfs_device_put(struct binder_device *dev)
+{
+       if (dev->binderfs_inode)
+               iput(dev->binderfs_inode);
+}
+
 /**
  * binderfs_mount_opts - mount options for binderfs
  * @max: maximum number of allocatable binderfs binder devices
```

### 3.2.2. vulnerability description
binder_release() 에서 실제 정리 작업을 작업 대기열에 펀트하는 binder_defer_work(proc, BINDER_DEFERRED_RELEASE)가 호출된다. 어느 시점에서 binder_deferred_func()가 호출되어 binder_deferred_release()를 호출하여 이 구조체 binder_proc에 연결된 binder_context를 검색하고 정리한다.  
이 binder_context가 binder_proc에 어디에서 연결되는지에 대해 추적해 나가면 binder_open()에서 연결되고,  struct binder_device 에서 가져온 것임을 알 수 있다.

```c
proc->context = &binder_dev->context;
```

이 코드는 컨텍스트가 연결된 struct binder_device가 *절대* 해제되지 않는다고 가정한다. devtmpfs 바인더 장치의 경우에는 사실일 수 있지만 binderfs binder device의 경우에는 잘못된 말이다. binderfs binder device에서 바인더_open()이 호출된다고 가정하자. 이제 해당 struct binder_device와 연결된 struct binder_context를 참조한다.

```c
            proc->context = &binder_dev->context;
            /* binderfs stashes devices in i_private */
            if (is_binderfs_device(nodp)) {
                    binder_dev = nodp->i_private;
                    info = nodp->i_sb->s_fs_info;
                    binder_binderfs_dir_entry_proc = info->proc_log_dir;
            } else {
            .
            .
            .
            proc->context = &binder_dev->context;
```			
    
이제 해당 binder device에 대한 binderfs 인스턴스가 umount()를 통해 종료되거나 이와 관련된 마운트 네임스페이스가 사라진다고 가정해 보겠다. binderfs binder device가 속한 fd가 열려 있는 한 문제가 없지만 해당 binderfs binder device의 마지막 fd를 닫는다면 binder_release()가 호출되고 workqueue에 편입된다.  
만약 workqueue에는 할 일이 꽤 많고 해당 binderfs binder device에 대해 struct binder_proc 및 연결된 struct binder_context를 즉시 정리하지 못한다면 그 동안 VFS는 슈퍼 블록을 죽이고 궁극적으로 sb->evict_inode()를 호출한다. 이는 결국 binderfs_evict_inode()를 호출한다는 의미이다.

```c    
    static void binderfs_evict_inode(struct inode *inode)
    {
            struct binder_device *device = inode->i_private;
            struct binderfs_info *info = BINDERFS_I(inode);
    
            clear_inode(inode);
    
            if (!S_ISCHR(inode->i_mode) || !device)
                    return;
    
            mutex_lock(&binderfs_minors_mutex);
            --info->device_count;
            ida_free(&binderfs_minors, device->miscdev.minor);
            mutex_unlock(&binderfs_minors_mutex);
    
            kfree(device->context.name);
            kfree(device);
    }
```	
    
이에 의해 struct bind_context를 포함하는 struct binder_device를 free 시킨다. 이제 workqueue는 마침내 struct binder_proc을 정리할 시간을 가지게 되었고 struct binder_context에 접근하려고 시도하지만 이미 해제되었으므로 UAF가 일어난다.  
작업 대기열이 struct binder_proc 정리를 완료한 후에만 해제되는 inode에 대한 추가 참조를 유지하여 이 문제를 수정하였다. 이것은 나중에 필요할 때 언제든지 할 수 있는 struct binder_device에 별도의 refcounting을 도입하는 것보다 쉬운 대안이다.

이것은 51d8a7eca677 에 대한 대안 수정이다("binder: print_binder_transaction_log_entry()에서 UAF 읽기 방지").

## 3.3. binder: prevent UAF for binderfs devices II
### 3.3.1. commit description
commit e8281e59c9d52ee844e28cbccd633360170931a7  
Author: Christian Brauner <christian.brauner@ubuntu.com>  
Date:   Tue Mar 3 17:43:40 2020 +0100  

UPSTREAM: binder: prevent UAF for binderfs devices II

    
